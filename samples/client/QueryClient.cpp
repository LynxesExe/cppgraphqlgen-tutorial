// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// WARNING! Do not edit this file manually, your changes will be overwritten.

#include "QueryClient.h"

#include <algorithm>
#include <array>
#include <sstream>
#include <string_view>

using namespace std::literals;

namespace graphql::query::Query {

const std::string& GetRequestText() noexcept
{
	static const auto s_request = R"gql(
		# Copyright (c) Microsoft Corporation. All rights reserved.
		# Licensed under the MIT License.
		
		query {
		  appointments {
		    edges {
		      node {
		        id
		        subject
		        when
		        isNow
		        __typename
		      }
		    }
		  }
		  tasks {
		    edges {
		      node {
		        id
		        title
		        isComplete
		        __typename
		      }
		    }
		  }
		  unreadCounts {
		    edges {
		      node {
		        id
		        name
		        unreadCount
		        __typename
		      }
		    }
		  }
		
		  # Read a field with an enum type
		  testTaskState
		}
	)gql"s;

	return s_request;
}

const peg::ast& GetRequestObject() noexcept
{
	static const auto s_request = []() noexcept {
		auto ast = peg::parseString(GetRequestText());

		// This has already been validated against the schema by clientgen.
		ast.validated = true;

		return ast;
	}();

	return s_request;
}

static const std::array<std::string_view, 4> s_namesTaskState = {
	"New"sv,
	"Started"sv,
	"Complete"sv,
	"Unassigned"sv,
};

TaskState parseTaskState(const response::Value& value)
{
	if (!value.maybe_enum())
	{
		throw service::schema_exception { { "not a valid TaskState value" } };
	}

	const auto itr = std::find(s_namesTaskState.cbegin(), s_namesTaskState.cend(), value.get<response::StringType>());

	if (itr == s_namesTaskState.cend())
	{
		throw service::schema_exception { { "not a valid TaskState value" } };
	}

	return static_cast<TaskState>(itr - s_namesTaskState.cbegin());
}

Response parseResponse(response::Value&& response)
{
	Response result;

	// appointments_AppointmentConnection appointments;
	// tasks_TaskConnection tasks;
	// unreadCounts_FolderConnection unreadCounts;
	// std::optional<TaskState> testTaskState;

	return result;
}

} /* namespace graphql::query::Query */
