// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// WARNING! Do not edit this file manually, your changes will be overwritten.

#pragma once

#ifndef TODAYSCHEMA_H
#define TODAYSCHEMA_H

#include "graphqlservice/internal/Schema.h"

// Check if the library version is compatible with schemagen 4.0.0
static_assert(graphql::internal::MajorVersion == 4, "regenerate with schemagen: major version mismatch");
static_assert(graphql::internal::MinorVersion == 0, "regenerate with schemagen: minor version mismatch");

#include <memory>
#include <string>
#include <vector>

namespace graphql {
namespace today {

enum class TaskState
{
	New,
	Started,
	Complete,
	Unassigned
};

struct CompleteTaskInput
{
	response::IdType id;
	std::optional<TaskState> testTaskState;
	std::optional<bool> isComplete;
	std::optional<std::string> clientMutationId;
};

struct ThirdNestedInput
{
	response::IdType id;
};

struct FourthNestedInput
{
	response::IdType id;
};

struct SecondNestedInput
{
	response::IdType id;
	ThirdNestedInput third;
};

struct FirstNestedInput
{
	response::IdType id;
	SecondNestedInput second;
	ThirdNestedInput third;
};

namespace object {

class Node;

class Query;
class PageInfo;
class AppointmentEdge;
class AppointmentConnection;
class TaskEdge;
class TaskConnection;
class FolderEdge;
class FolderConnection;
class CompleteTaskPayload;
class Mutation;
class Subscription;
class Appointment;
class Task;
class Folder;
class NestedType;
class Expensive;

class Node
	: public service::Object
{
private:
	struct Concept
	{
		virtual ~Concept() = default;

		virtual service::TypeNames getTypeNames() const noexcept = 0;
		virtual service::ResolverMap getResolvers() const noexcept = 0;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;		
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::TypeNames getTypeNames() const noexcept final
		{
			return _pimpl->getTypeNames();
		}

		service::ResolverMap getResolvers() const noexcept final
		{
			return _pimpl->getResolvers();
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			_pimpl->beginSelectionSet(params);
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			_pimpl->endSelectionSet(params);
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	Node(std::unique_ptr<Concept>&& pimpl) noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	Node(std::shared_ptr<T> pimpl) noexcept
		: Node { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
		static_assert(T::template implements<Node>(), "Node is not implemented");
	}
};

namespace implements {

template <class I>
concept AppointmentIs = std::is_same_v<I, Node>;

template <class I>
concept TaskIs = std::is_same_v<I, Node>;

template <class I>
concept FolderIs = std::is_same_v<I, Node>;

} // namespace implements

namespace methods {
namespace QueryHas {

template <class TImpl>
concept getNodeWithParams = requires (TImpl impl, service::FieldParams params, response::IdType idArg) 
{
	{ service::FieldResult<std::shared_ptr<Node>> { impl.getNode(std::move(params), std::move(idArg)) } };
};

template <class TImpl>
concept getNode = requires (TImpl impl, response::IdType idArg) 
{
	{ service::FieldResult<std::shared_ptr<Node>> { impl.getNode(std::move(idArg)) } };
};

template <class TImpl>
concept getAppointmentsWithParams = requires (TImpl impl, service::FieldParams params, std::optional<int> firstArg, std::optional<response::Value> afterArg, std::optional<int> lastArg, std::optional<response::Value> beforeArg) 
{
	{ service::FieldResult<std::shared_ptr<AppointmentConnection>> { impl.getAppointments(std::move(params), std::move(firstArg), std::move(afterArg), std::move(lastArg), std::move(beforeArg)) } };
};

template <class TImpl>
concept getAppointments = requires (TImpl impl, std::optional<int> firstArg, std::optional<response::Value> afterArg, std::optional<int> lastArg, std::optional<response::Value> beforeArg) 
{
	{ service::FieldResult<std::shared_ptr<AppointmentConnection>> { impl.getAppointments(std::move(firstArg), std::move(afterArg), std::move(lastArg), std::move(beforeArg)) } };
};

template <class TImpl>
concept getTasksWithParams = requires (TImpl impl, service::FieldParams params, std::optional<int> firstArg, std::optional<response::Value> afterArg, std::optional<int> lastArg, std::optional<response::Value> beforeArg) 
{
	{ service::FieldResult<std::shared_ptr<TaskConnection>> { impl.getTasks(std::move(params), std::move(firstArg), std::move(afterArg), std::move(lastArg), std::move(beforeArg)) } };
};

template <class TImpl>
concept getTasks = requires (TImpl impl, std::optional<int> firstArg, std::optional<response::Value> afterArg, std::optional<int> lastArg, std::optional<response::Value> beforeArg) 
{
	{ service::FieldResult<std::shared_ptr<TaskConnection>> { impl.getTasks(std::move(firstArg), std::move(afterArg), std::move(lastArg), std::move(beforeArg)) } };
};

template <class TImpl>
concept getUnreadCountsWithParams = requires (TImpl impl, service::FieldParams params, std::optional<int> firstArg, std::optional<response::Value> afterArg, std::optional<int> lastArg, std::optional<response::Value> beforeArg) 
{
	{ service::FieldResult<std::shared_ptr<FolderConnection>> { impl.getUnreadCounts(std::move(params), std::move(firstArg), std::move(afterArg), std::move(lastArg), std::move(beforeArg)) } };
};

template <class TImpl>
concept getUnreadCounts = requires (TImpl impl, std::optional<int> firstArg, std::optional<response::Value> afterArg, std::optional<int> lastArg, std::optional<response::Value> beforeArg) 
{
	{ service::FieldResult<std::shared_ptr<FolderConnection>> { impl.getUnreadCounts(std::move(firstArg), std::move(afterArg), std::move(lastArg), std::move(beforeArg)) } };
};

template <class TImpl>
concept getAppointmentsByIdWithParams = requires (TImpl impl, service::FieldParams params, std::vector<response::IdType> idsArg) 
{
	{ service::FieldResult<std::vector<std::shared_ptr<Appointment>>> { impl.getAppointmentsById(std::move(params), std::move(idsArg)) } };
};

template <class TImpl>
concept getAppointmentsById = requires (TImpl impl, std::vector<response::IdType> idsArg) 
{
	{ service::FieldResult<std::vector<std::shared_ptr<Appointment>>> { impl.getAppointmentsById(std::move(idsArg)) } };
};

template <class TImpl>
concept getTasksByIdWithParams = requires (TImpl impl, service::FieldParams params, std::vector<response::IdType> idsArg) 
{
	{ service::FieldResult<std::vector<std::shared_ptr<Task>>> { impl.getTasksById(std::move(params), std::move(idsArg)) } };
};

template <class TImpl>
concept getTasksById = requires (TImpl impl, std::vector<response::IdType> idsArg) 
{
	{ service::FieldResult<std::vector<std::shared_ptr<Task>>> { impl.getTasksById(std::move(idsArg)) } };
};

template <class TImpl>
concept getUnreadCountsByIdWithParams = requires (TImpl impl, service::FieldParams params, std::vector<response::IdType> idsArg) 
{
	{ service::FieldResult<std::vector<std::shared_ptr<Folder>>> { impl.getUnreadCountsById(std::move(params), std::move(idsArg)) } };
};

template <class TImpl>
concept getUnreadCountsById = requires (TImpl impl, std::vector<response::IdType> idsArg) 
{
	{ service::FieldResult<std::vector<std::shared_ptr<Folder>>> { impl.getUnreadCountsById(std::move(idsArg)) } };
};

template <class TImpl>
concept getNestedWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::shared_ptr<NestedType>> { impl.getNested(std::move(params)) } };
};

template <class TImpl>
concept getNested = requires (TImpl impl) 
{
	{ service::FieldResult<std::shared_ptr<NestedType>> { impl.getNested() } };
};

template <class TImpl>
concept getUnimplementedWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::string> { impl.getUnimplemented(std::move(params)) } };
};

template <class TImpl>
concept getUnimplemented = requires (TImpl impl) 
{
	{ service::FieldResult<std::string> { impl.getUnimplemented() } };
};

template <class TImpl>
concept getExpensiveWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::vector<std::shared_ptr<Expensive>>> { impl.getExpensive(std::move(params)) } };
};

template <class TImpl>
concept getExpensive = requires (TImpl impl) 
{
	{ service::FieldResult<std::vector<std::shared_ptr<Expensive>>> { impl.getExpensive() } };
};

template <class TImpl>
concept getTestTaskStateWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<TaskState> { impl.getTestTaskState(std::move(params)) } };
};

template <class TImpl>
concept getTestTaskState = requires (TImpl impl) 
{
	{ service::FieldResult<TaskState> { impl.getTestTaskState() } };
};

template <class TImpl>
concept getAnyTypeWithParams = requires (TImpl impl, service::FieldParams params, std::vector<response::IdType> idsArg) 
{
	{ service::FieldResult<std::vector<std::shared_ptr<service::Object>>> { impl.getAnyType(std::move(params), std::move(idsArg)) } };
};

template <class TImpl>
concept getAnyType = requires (TImpl impl, std::vector<response::IdType> idsArg) 
{
	{ service::FieldResult<std::vector<std::shared_ptr<service::Object>>> { impl.getAnyType(std::move(idsArg)) } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace QueryHas

namespace PageInfoHas {

template <class TImpl>
concept getHasNextPageWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<bool> { impl.getHasNextPage(std::move(params)) } };
};

template <class TImpl>
concept getHasNextPage = requires (TImpl impl) 
{
	{ service::FieldResult<bool> { impl.getHasNextPage() } };
};

template <class TImpl>
concept getHasPreviousPageWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<bool> { impl.getHasPreviousPage(std::move(params)) } };
};

template <class TImpl>
concept getHasPreviousPage = requires (TImpl impl) 
{
	{ service::FieldResult<bool> { impl.getHasPreviousPage() } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace PageInfoHas

namespace AppointmentEdgeHas {

template <class TImpl>
concept getNodeWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::shared_ptr<Appointment>> { impl.getNode(std::move(params)) } };
};

template <class TImpl>
concept getNode = requires (TImpl impl) 
{
	{ service::FieldResult<std::shared_ptr<Appointment>> { impl.getNode() } };
};

template <class TImpl>
concept getCursorWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<response::Value> { impl.getCursor(std::move(params)) } };
};

template <class TImpl>
concept getCursor = requires (TImpl impl) 
{
	{ service::FieldResult<response::Value> { impl.getCursor() } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace AppointmentEdgeHas

namespace AppointmentConnectionHas {

template <class TImpl>
concept getPageInfoWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::shared_ptr<PageInfo>> { impl.getPageInfo(std::move(params)) } };
};

template <class TImpl>
concept getPageInfo = requires (TImpl impl) 
{
	{ service::FieldResult<std::shared_ptr<PageInfo>> { impl.getPageInfo() } };
};

template <class TImpl>
concept getEdgesWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::optional<std::vector<std::shared_ptr<AppointmentEdge>>>> { impl.getEdges(std::move(params)) } };
};

template <class TImpl>
concept getEdges = requires (TImpl impl) 
{
	{ service::FieldResult<std::optional<std::vector<std::shared_ptr<AppointmentEdge>>>> { impl.getEdges() } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace AppointmentConnectionHas

namespace TaskEdgeHas {

template <class TImpl>
concept getNodeWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::shared_ptr<Task>> { impl.getNode(std::move(params)) } };
};

template <class TImpl>
concept getNode = requires (TImpl impl) 
{
	{ service::FieldResult<std::shared_ptr<Task>> { impl.getNode() } };
};

template <class TImpl>
concept getCursorWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<response::Value> { impl.getCursor(std::move(params)) } };
};

template <class TImpl>
concept getCursor = requires (TImpl impl) 
{
	{ service::FieldResult<response::Value> { impl.getCursor() } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace TaskEdgeHas

namespace TaskConnectionHas {

template <class TImpl>
concept getPageInfoWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::shared_ptr<PageInfo>> { impl.getPageInfo(std::move(params)) } };
};

template <class TImpl>
concept getPageInfo = requires (TImpl impl) 
{
	{ service::FieldResult<std::shared_ptr<PageInfo>> { impl.getPageInfo() } };
};

template <class TImpl>
concept getEdgesWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::optional<std::vector<std::shared_ptr<TaskEdge>>>> { impl.getEdges(std::move(params)) } };
};

template <class TImpl>
concept getEdges = requires (TImpl impl) 
{
	{ service::FieldResult<std::optional<std::vector<std::shared_ptr<TaskEdge>>>> { impl.getEdges() } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace TaskConnectionHas

namespace FolderEdgeHas {

template <class TImpl>
concept getNodeWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::shared_ptr<Folder>> { impl.getNode(std::move(params)) } };
};

template <class TImpl>
concept getNode = requires (TImpl impl) 
{
	{ service::FieldResult<std::shared_ptr<Folder>> { impl.getNode() } };
};

template <class TImpl>
concept getCursorWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<response::Value> { impl.getCursor(std::move(params)) } };
};

template <class TImpl>
concept getCursor = requires (TImpl impl) 
{
	{ service::FieldResult<response::Value> { impl.getCursor() } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace FolderEdgeHas

namespace FolderConnectionHas {

template <class TImpl>
concept getPageInfoWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::shared_ptr<PageInfo>> { impl.getPageInfo(std::move(params)) } };
};

template <class TImpl>
concept getPageInfo = requires (TImpl impl) 
{
	{ service::FieldResult<std::shared_ptr<PageInfo>> { impl.getPageInfo() } };
};

template <class TImpl>
concept getEdgesWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::optional<std::vector<std::shared_ptr<FolderEdge>>>> { impl.getEdges(std::move(params)) } };
};

template <class TImpl>
concept getEdges = requires (TImpl impl) 
{
	{ service::FieldResult<std::optional<std::vector<std::shared_ptr<FolderEdge>>>> { impl.getEdges() } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace FolderConnectionHas

namespace CompleteTaskPayloadHas {

template <class TImpl>
concept getTaskWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::shared_ptr<Task>> { impl.getTask(std::move(params)) } };
};

template <class TImpl>
concept getTask = requires (TImpl impl) 
{
	{ service::FieldResult<std::shared_ptr<Task>> { impl.getTask() } };
};

template <class TImpl>
concept getClientMutationIdWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::optional<std::string>> { impl.getClientMutationId(std::move(params)) } };
};

template <class TImpl>
concept getClientMutationId = requires (TImpl impl) 
{
	{ service::FieldResult<std::optional<std::string>> { impl.getClientMutationId() } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace CompleteTaskPayloadHas

namespace MutationHas {

template <class TImpl>
concept applyCompleteTaskWithParams = requires (TImpl impl, service::FieldParams params, CompleteTaskInput inputArg) 
{
	{ service::FieldResult<std::shared_ptr<CompleteTaskPayload>> { impl.applyCompleteTask(std::move(params), std::move(inputArg)) } };
};

template <class TImpl>
concept applyCompleteTask = requires (TImpl impl, CompleteTaskInput inputArg) 
{
	{ service::FieldResult<std::shared_ptr<CompleteTaskPayload>> { impl.applyCompleteTask(std::move(inputArg)) } };
};

template <class TImpl>
concept applySetFloatWithParams = requires (TImpl impl, service::FieldParams params, double valueArg) 
{
	{ service::FieldResult<double> { impl.applySetFloat(std::move(params), std::move(valueArg)) } };
};

template <class TImpl>
concept applySetFloat = requires (TImpl impl, double valueArg) 
{
	{ service::FieldResult<double> { impl.applySetFloat(std::move(valueArg)) } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace MutationHas

namespace SubscriptionHas {

template <class TImpl>
concept getNextAppointmentChangeWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::shared_ptr<Appointment>> { impl.getNextAppointmentChange(std::move(params)) } };
};

template <class TImpl>
concept getNextAppointmentChange = requires (TImpl impl) 
{
	{ service::FieldResult<std::shared_ptr<Appointment>> { impl.getNextAppointmentChange() } };
};

template <class TImpl>
concept getNodeChangeWithParams = requires (TImpl impl, service::FieldParams params, response::IdType idArg) 
{
	{ service::FieldResult<std::shared_ptr<Node>> { impl.getNodeChange(std::move(params), std::move(idArg)) } };
};

template <class TImpl>
concept getNodeChange = requires (TImpl impl, response::IdType idArg) 
{
	{ service::FieldResult<std::shared_ptr<Node>> { impl.getNodeChange(std::move(idArg)) } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace SubscriptionHas

namespace AppointmentHas {

template <class TImpl>
concept getIdWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<response::IdType> { impl.getId(std::move(params)) } };
};

template <class TImpl>
concept getId = requires (TImpl impl) 
{
	{ service::FieldResult<response::IdType> { impl.getId() } };
};

template <class TImpl>
concept getWhenWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::optional<response::Value>> { impl.getWhen(std::move(params)) } };
};

template <class TImpl>
concept getWhen = requires (TImpl impl) 
{
	{ service::FieldResult<std::optional<response::Value>> { impl.getWhen() } };
};

template <class TImpl>
concept getSubjectWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::optional<std::string>> { impl.getSubject(std::move(params)) } };
};

template <class TImpl>
concept getSubject = requires (TImpl impl) 
{
	{ service::FieldResult<std::optional<std::string>> { impl.getSubject() } };
};

template <class TImpl>
concept getIsNowWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<bool> { impl.getIsNow(std::move(params)) } };
};

template <class TImpl>
concept getIsNow = requires (TImpl impl) 
{
	{ service::FieldResult<bool> { impl.getIsNow() } };
};

template <class TImpl>
concept getForceErrorWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::optional<std::string>> { impl.getForceError(std::move(params)) } };
};

template <class TImpl>
concept getForceError = requires (TImpl impl) 
{
	{ service::FieldResult<std::optional<std::string>> { impl.getForceError() } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace AppointmentHas

namespace TaskHas {

template <class TImpl>
concept getIdWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<response::IdType> { impl.getId(std::move(params)) } };
};

template <class TImpl>
concept getId = requires (TImpl impl) 
{
	{ service::FieldResult<response::IdType> { impl.getId() } };
};

template <class TImpl>
concept getTitleWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::optional<std::string>> { impl.getTitle(std::move(params)) } };
};

template <class TImpl>
concept getTitle = requires (TImpl impl) 
{
	{ service::FieldResult<std::optional<std::string>> { impl.getTitle() } };
};

template <class TImpl>
concept getIsCompleteWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<bool> { impl.getIsComplete(std::move(params)) } };
};

template <class TImpl>
concept getIsComplete = requires (TImpl impl) 
{
	{ service::FieldResult<bool> { impl.getIsComplete() } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace TaskHas

namespace FolderHas {

template <class TImpl>
concept getIdWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<response::IdType> { impl.getId(std::move(params)) } };
};

template <class TImpl>
concept getId = requires (TImpl impl) 
{
	{ service::FieldResult<response::IdType> { impl.getId() } };
};

template <class TImpl>
concept getNameWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::optional<std::string>> { impl.getName(std::move(params)) } };
};

template <class TImpl>
concept getName = requires (TImpl impl) 
{
	{ service::FieldResult<std::optional<std::string>> { impl.getName() } };
};

template <class TImpl>
concept getUnreadCountWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<int> { impl.getUnreadCount(std::move(params)) } };
};

template <class TImpl>
concept getUnreadCount = requires (TImpl impl) 
{
	{ service::FieldResult<int> { impl.getUnreadCount() } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace FolderHas

namespace NestedTypeHas {

template <class TImpl>
concept getDepthWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<int> { impl.getDepth(std::move(params)) } };
};

template <class TImpl>
concept getDepth = requires (TImpl impl) 
{
	{ service::FieldResult<int> { impl.getDepth() } };
};

template <class TImpl>
concept getNestedWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<std::shared_ptr<NestedType>> { impl.getNested(std::move(params)) } };
};

template <class TImpl>
concept getNested = requires (TImpl impl) 
{
	{ service::FieldResult<std::shared_ptr<NestedType>> { impl.getNested() } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace NestedTypeHas

namespace ExpensiveHas {

template <class TImpl>
concept getOrderWithParams = requires (TImpl impl, service::FieldParams params) 
{
	{ service::FieldResult<int> { impl.getOrder(std::move(params)) } };
};

template <class TImpl>
concept getOrder = requires (TImpl impl) 
{
	{ service::FieldResult<int> { impl.getOrder() } };
};

template <class TImpl>
concept beginSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.beginSelectionSet(params) };
};

template <class TImpl>
concept endSelectionSet = requires (TImpl impl, const service::SelectionSetParams params) 
{
	{ impl.endSelectionSet(params) };
};

} // namespace ExpensiveHas
} // namespace methods

class Query
	: public service::Object
{
private:
	service::AwaitableResolver resolveNode(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveAppointments(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveTasks(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveUnreadCounts(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveAppointmentsById(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveTasksById(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveUnreadCountsById(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveNested(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveUnimplemented(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveExpensive(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveTestTaskState(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveAnyType(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<std::shared_ptr<Node>> getNode(service::FieldParams&& params, response::IdType&& idArg) const = 0;
		virtual service::FieldResult<std::shared_ptr<AppointmentConnection>> getAppointments(service::FieldParams&& params, std::optional<int>&& firstArg, std::optional<response::Value>&& afterArg, std::optional<int>&& lastArg, std::optional<response::Value>&& beforeArg) const = 0;
		virtual service::FieldResult<std::shared_ptr<TaskConnection>> getTasks(service::FieldParams&& params, std::optional<int>&& firstArg, std::optional<response::Value>&& afterArg, std::optional<int>&& lastArg, std::optional<response::Value>&& beforeArg) const = 0;
		virtual service::FieldResult<std::shared_ptr<FolderConnection>> getUnreadCounts(service::FieldParams&& params, std::optional<int>&& firstArg, std::optional<response::Value>&& afterArg, std::optional<int>&& lastArg, std::optional<response::Value>&& beforeArg) const = 0;
		virtual service::FieldResult<std::vector<std::shared_ptr<Appointment>>> getAppointmentsById(service::FieldParams&& params, std::vector<response::IdType>&& idsArg) const = 0;
		virtual service::FieldResult<std::vector<std::shared_ptr<Task>>> getTasksById(service::FieldParams&& params, std::vector<response::IdType>&& idsArg) const = 0;
		virtual service::FieldResult<std::vector<std::shared_ptr<Folder>>> getUnreadCountsById(service::FieldParams&& params, std::vector<response::IdType>&& idsArg) const = 0;
		virtual service::FieldResult<std::shared_ptr<NestedType>> getNested(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::string> getUnimplemented(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::vector<std::shared_ptr<Expensive>>> getExpensive(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<TaskState> getTestTaskState(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::vector<std::shared_ptr<service::Object>>> getAnyType(service::FieldParams&& params, std::vector<response::IdType>&& idsArg) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<std::shared_ptr<Node>> getNode(service::FieldParams&& params, response::IdType&& idArg) const final
		{
			if constexpr (methods::QueryHas::getNodeWithParams<T>)
			{
				return { _pimpl->getNode(std::move(params), std::move(idArg)) };
			}
			else if constexpr (methods::QueryHas::getNode<T>)
			{
				return { _pimpl->getNode(std::move(idArg)) };
			}
			else
			{
				throw std::runtime_error(R"ex(Query::getNode is not implemented)ex");
			}
		}

		service::FieldResult<std::shared_ptr<AppointmentConnection>> getAppointments(service::FieldParams&& params, std::optional<int>&& firstArg, std::optional<response::Value>&& afterArg, std::optional<int>&& lastArg, std::optional<response::Value>&& beforeArg) const final
		{
			if constexpr (methods::QueryHas::getAppointmentsWithParams<T>)
			{
				return { _pimpl->getAppointments(std::move(params), std::move(firstArg), std::move(afterArg), std::move(lastArg), std::move(beforeArg)) };
			}
			else if constexpr (methods::QueryHas::getAppointments<T>)
			{
				return { _pimpl->getAppointments(std::move(firstArg), std::move(afterArg), std::move(lastArg), std::move(beforeArg)) };
			}
			else
			{
				throw std::runtime_error(R"ex(Query::getAppointments is not implemented)ex");
			}
		}

		service::FieldResult<std::shared_ptr<TaskConnection>> getTasks(service::FieldParams&& params, std::optional<int>&& firstArg, std::optional<response::Value>&& afterArg, std::optional<int>&& lastArg, std::optional<response::Value>&& beforeArg) const final
		{
			if constexpr (methods::QueryHas::getTasksWithParams<T>)
			{
				return { _pimpl->getTasks(std::move(params), std::move(firstArg), std::move(afterArg), std::move(lastArg), std::move(beforeArg)) };
			}
			else if constexpr (methods::QueryHas::getTasks<T>)
			{
				return { _pimpl->getTasks(std::move(firstArg), std::move(afterArg), std::move(lastArg), std::move(beforeArg)) };
			}
			else
			{
				throw std::runtime_error(R"ex(Query::getTasks is not implemented)ex");
			}
		}

		service::FieldResult<std::shared_ptr<FolderConnection>> getUnreadCounts(service::FieldParams&& params, std::optional<int>&& firstArg, std::optional<response::Value>&& afterArg, std::optional<int>&& lastArg, std::optional<response::Value>&& beforeArg) const final
		{
			if constexpr (methods::QueryHas::getUnreadCountsWithParams<T>)
			{
				return { _pimpl->getUnreadCounts(std::move(params), std::move(firstArg), std::move(afterArg), std::move(lastArg), std::move(beforeArg)) };
			}
			else if constexpr (methods::QueryHas::getUnreadCounts<T>)
			{
				return { _pimpl->getUnreadCounts(std::move(firstArg), std::move(afterArg), std::move(lastArg), std::move(beforeArg)) };
			}
			else
			{
				throw std::runtime_error(R"ex(Query::getUnreadCounts is not implemented)ex");
			}
		}

		service::FieldResult<std::vector<std::shared_ptr<Appointment>>> getAppointmentsById(service::FieldParams&& params, std::vector<response::IdType>&& idsArg) const final
		{
			if constexpr (methods::QueryHas::getAppointmentsByIdWithParams<T>)
			{
				return { _pimpl->getAppointmentsById(std::move(params), std::move(idsArg)) };
			}
			else if constexpr (methods::QueryHas::getAppointmentsById<T>)
			{
				return { _pimpl->getAppointmentsById(std::move(idsArg)) };
			}
			else
			{
				throw std::runtime_error(R"ex(Query::getAppointmentsById is not implemented)ex");
			}
		}

		service::FieldResult<std::vector<std::shared_ptr<Task>>> getTasksById(service::FieldParams&& params, std::vector<response::IdType>&& idsArg) const final
		{
			if constexpr (methods::QueryHas::getTasksByIdWithParams<T>)
			{
				return { _pimpl->getTasksById(std::move(params), std::move(idsArg)) };
			}
			else if constexpr (methods::QueryHas::getTasksById<T>)
			{
				return { _pimpl->getTasksById(std::move(idsArg)) };
			}
			else
			{
				throw std::runtime_error(R"ex(Query::getTasksById is not implemented)ex");
			}
		}

		service::FieldResult<std::vector<std::shared_ptr<Folder>>> getUnreadCountsById(service::FieldParams&& params, std::vector<response::IdType>&& idsArg) const final
		{
			if constexpr (methods::QueryHas::getUnreadCountsByIdWithParams<T>)
			{
				return { _pimpl->getUnreadCountsById(std::move(params), std::move(idsArg)) };
			}
			else if constexpr (methods::QueryHas::getUnreadCountsById<T>)
			{
				return { _pimpl->getUnreadCountsById(std::move(idsArg)) };
			}
			else
			{
				throw std::runtime_error(R"ex(Query::getUnreadCountsById is not implemented)ex");
			}
		}

		service::FieldResult<std::shared_ptr<NestedType>> getNested(service::FieldParams&& params) const final
		{
			if constexpr (methods::QueryHas::getNestedWithParams<T>)
			{
				return { _pimpl->getNested(std::move(params)) };
			}
			else if constexpr (methods::QueryHas::getNested<T>)
			{
				return { _pimpl->getNested() };
			}
			else
			{
				throw std::runtime_error(R"ex(Query::getNested is not implemented)ex");
			}
		}

		service::FieldResult<std::string> getUnimplemented(service::FieldParams&& params) const final
		{
			if constexpr (methods::QueryHas::getUnimplementedWithParams<T>)
			{
				return { _pimpl->getUnimplemented(std::move(params)) };
			}
			else if constexpr (methods::QueryHas::getUnimplemented<T>)
			{
				return { _pimpl->getUnimplemented() };
			}
			else
			{
				throw std::runtime_error(R"ex(Query::getUnimplemented is not implemented)ex");
			}
		}

		service::FieldResult<std::vector<std::shared_ptr<Expensive>>> getExpensive(service::FieldParams&& params) const final
		{
			if constexpr (methods::QueryHas::getExpensiveWithParams<T>)
			{
				return { _pimpl->getExpensive(std::move(params)) };
			}
			else if constexpr (methods::QueryHas::getExpensive<T>)
			{
				return { _pimpl->getExpensive() };
			}
			else
			{
				throw std::runtime_error(R"ex(Query::getExpensive is not implemented)ex");
			}
		}

		service::FieldResult<TaskState> getTestTaskState(service::FieldParams&& params) const final
		{
			if constexpr (methods::QueryHas::getTestTaskStateWithParams<T>)
			{
				return { _pimpl->getTestTaskState(std::move(params)) };
			}
			else if constexpr (methods::QueryHas::getTestTaskState<T>)
			{
				return { _pimpl->getTestTaskState() };
			}
			else
			{
				throw std::runtime_error(R"ex(Query::getTestTaskState is not implemented)ex");
			}
		}

		service::FieldResult<std::vector<std::shared_ptr<service::Object>>> getAnyType(service::FieldParams&& params, std::vector<response::IdType>&& idsArg) const final
		{
			if constexpr (methods::QueryHas::getAnyTypeWithParams<T>)
			{
				return { _pimpl->getAnyType(std::move(params), std::move(idsArg)) };
			}
			else if constexpr (methods::QueryHas::getAnyType<T>)
			{
				return { _pimpl->getAnyType(std::move(idsArg)) };
			}
			else
			{
				throw std::runtime_error(R"ex(Query::getAnyType is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::QueryHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::QueryHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	Query(std::unique_ptr<Concept>&& pimpl) noexcept;

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	Query(std::shared_ptr<T> pimpl) noexcept
		: Query { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class PageInfo
	: public service::Object
{
private:
	service::AwaitableResolver resolveHasNextPage(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveHasPreviousPage(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<bool> getHasNextPage(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<bool> getHasPreviousPage(service::FieldParams&& params) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<bool> getHasNextPage(service::FieldParams&& params) const final
		{
			if constexpr (methods::PageInfoHas::getHasNextPageWithParams<T>)
			{
				return { _pimpl->getHasNextPage(std::move(params)) };
			}
			else if constexpr (methods::PageInfoHas::getHasNextPage<T>)
			{
				return { _pimpl->getHasNextPage() };
			}
			else
			{
				throw std::runtime_error(R"ex(PageInfo::getHasNextPage is not implemented)ex");
			}
		}

		service::FieldResult<bool> getHasPreviousPage(service::FieldParams&& params) const final
		{
			if constexpr (methods::PageInfoHas::getHasPreviousPageWithParams<T>)
			{
				return { _pimpl->getHasPreviousPage(std::move(params)) };
			}
			else if constexpr (methods::PageInfoHas::getHasPreviousPage<T>)
			{
				return { _pimpl->getHasPreviousPage() };
			}
			else
			{
				throw std::runtime_error(R"ex(PageInfo::getHasPreviousPage is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::PageInfoHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::PageInfoHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	PageInfo(std::unique_ptr<Concept>&& pimpl) noexcept;

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	PageInfo(std::shared_ptr<T> pimpl) noexcept
		: PageInfo { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class AppointmentEdge
	: public service::Object
{
private:
	service::AwaitableResolver resolveNode(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveCursor(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<std::shared_ptr<Appointment>> getNode(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<response::Value> getCursor(service::FieldParams&& params) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<std::shared_ptr<Appointment>> getNode(service::FieldParams&& params) const final
		{
			if constexpr (methods::AppointmentEdgeHas::getNodeWithParams<T>)
			{
				return { _pimpl->getNode(std::move(params)) };
			}
			else if constexpr (methods::AppointmentEdgeHas::getNode<T>)
			{
				return { _pimpl->getNode() };
			}
			else
			{
				throw std::runtime_error(R"ex(AppointmentEdge::getNode is not implemented)ex");
			}
		}

		service::FieldResult<response::Value> getCursor(service::FieldParams&& params) const final
		{
			if constexpr (methods::AppointmentEdgeHas::getCursorWithParams<T>)
			{
				return { _pimpl->getCursor(std::move(params)) };
			}
			else if constexpr (methods::AppointmentEdgeHas::getCursor<T>)
			{
				return { _pimpl->getCursor() };
			}
			else
			{
				throw std::runtime_error(R"ex(AppointmentEdge::getCursor is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::AppointmentEdgeHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::AppointmentEdgeHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	AppointmentEdge(std::unique_ptr<Concept>&& pimpl) noexcept;

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	AppointmentEdge(std::shared_ptr<T> pimpl) noexcept
		: AppointmentEdge { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class AppointmentConnection
	: public service::Object
{
private:
	service::AwaitableResolver resolvePageInfo(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveEdges(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<std::shared_ptr<PageInfo>> getPageInfo(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::optional<std::vector<std::shared_ptr<AppointmentEdge>>>> getEdges(service::FieldParams&& params) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<std::shared_ptr<PageInfo>> getPageInfo(service::FieldParams&& params) const final
		{
			if constexpr (methods::AppointmentConnectionHas::getPageInfoWithParams<T>)
			{
				return { _pimpl->getPageInfo(std::move(params)) };
			}
			else if constexpr (methods::AppointmentConnectionHas::getPageInfo<T>)
			{
				return { _pimpl->getPageInfo() };
			}
			else
			{
				throw std::runtime_error(R"ex(AppointmentConnection::getPageInfo is not implemented)ex");
			}
		}

		service::FieldResult<std::optional<std::vector<std::shared_ptr<AppointmentEdge>>>> getEdges(service::FieldParams&& params) const final
		{
			if constexpr (methods::AppointmentConnectionHas::getEdgesWithParams<T>)
			{
				return { _pimpl->getEdges(std::move(params)) };
			}
			else if constexpr (methods::AppointmentConnectionHas::getEdges<T>)
			{
				return { _pimpl->getEdges() };
			}
			else
			{
				throw std::runtime_error(R"ex(AppointmentConnection::getEdges is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::AppointmentConnectionHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::AppointmentConnectionHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	AppointmentConnection(std::unique_ptr<Concept>&& pimpl) noexcept;

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	AppointmentConnection(std::shared_ptr<T> pimpl) noexcept
		: AppointmentConnection { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class TaskEdge
	: public service::Object
{
private:
	service::AwaitableResolver resolveNode(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveCursor(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<std::shared_ptr<Task>> getNode(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<response::Value> getCursor(service::FieldParams&& params) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<std::shared_ptr<Task>> getNode(service::FieldParams&& params) const final
		{
			if constexpr (methods::TaskEdgeHas::getNodeWithParams<T>)
			{
				return { _pimpl->getNode(std::move(params)) };
			}
			else if constexpr (methods::TaskEdgeHas::getNode<T>)
			{
				return { _pimpl->getNode() };
			}
			else
			{
				throw std::runtime_error(R"ex(TaskEdge::getNode is not implemented)ex");
			}
		}

		service::FieldResult<response::Value> getCursor(service::FieldParams&& params) const final
		{
			if constexpr (methods::TaskEdgeHas::getCursorWithParams<T>)
			{
				return { _pimpl->getCursor(std::move(params)) };
			}
			else if constexpr (methods::TaskEdgeHas::getCursor<T>)
			{
				return { _pimpl->getCursor() };
			}
			else
			{
				throw std::runtime_error(R"ex(TaskEdge::getCursor is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::TaskEdgeHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::TaskEdgeHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	TaskEdge(std::unique_ptr<Concept>&& pimpl) noexcept;

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	TaskEdge(std::shared_ptr<T> pimpl) noexcept
		: TaskEdge { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class TaskConnection
	: public service::Object
{
private:
	service::AwaitableResolver resolvePageInfo(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveEdges(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<std::shared_ptr<PageInfo>> getPageInfo(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::optional<std::vector<std::shared_ptr<TaskEdge>>>> getEdges(service::FieldParams&& params) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<std::shared_ptr<PageInfo>> getPageInfo(service::FieldParams&& params) const final
		{
			if constexpr (methods::TaskConnectionHas::getPageInfoWithParams<T>)
			{
				return { _pimpl->getPageInfo(std::move(params)) };
			}
			else if constexpr (methods::TaskConnectionHas::getPageInfo<T>)
			{
				return { _pimpl->getPageInfo() };
			}
			else
			{
				throw std::runtime_error(R"ex(TaskConnection::getPageInfo is not implemented)ex");
			}
		}

		service::FieldResult<std::optional<std::vector<std::shared_ptr<TaskEdge>>>> getEdges(service::FieldParams&& params) const final
		{
			if constexpr (methods::TaskConnectionHas::getEdgesWithParams<T>)
			{
				return { _pimpl->getEdges(std::move(params)) };
			}
			else if constexpr (methods::TaskConnectionHas::getEdges<T>)
			{
				return { _pimpl->getEdges() };
			}
			else
			{
				throw std::runtime_error(R"ex(TaskConnection::getEdges is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::TaskConnectionHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::TaskConnectionHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	TaskConnection(std::unique_ptr<Concept>&& pimpl) noexcept;

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	TaskConnection(std::shared_ptr<T> pimpl) noexcept
		: TaskConnection { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class FolderEdge
	: public service::Object
{
private:
	service::AwaitableResolver resolveNode(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveCursor(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<std::shared_ptr<Folder>> getNode(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<response::Value> getCursor(service::FieldParams&& params) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<std::shared_ptr<Folder>> getNode(service::FieldParams&& params) const final
		{
			if constexpr (methods::FolderEdgeHas::getNodeWithParams<T>)
			{
				return { _pimpl->getNode(std::move(params)) };
			}
			else if constexpr (methods::FolderEdgeHas::getNode<T>)
			{
				return { _pimpl->getNode() };
			}
			else
			{
				throw std::runtime_error(R"ex(FolderEdge::getNode is not implemented)ex");
			}
		}

		service::FieldResult<response::Value> getCursor(service::FieldParams&& params) const final
		{
			if constexpr (methods::FolderEdgeHas::getCursorWithParams<T>)
			{
				return { _pimpl->getCursor(std::move(params)) };
			}
			else if constexpr (methods::FolderEdgeHas::getCursor<T>)
			{
				return { _pimpl->getCursor() };
			}
			else
			{
				throw std::runtime_error(R"ex(FolderEdge::getCursor is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::FolderEdgeHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::FolderEdgeHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	FolderEdge(std::unique_ptr<Concept>&& pimpl) noexcept;

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	FolderEdge(std::shared_ptr<T> pimpl) noexcept
		: FolderEdge { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class FolderConnection
	: public service::Object
{
private:
	service::AwaitableResolver resolvePageInfo(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveEdges(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<std::shared_ptr<PageInfo>> getPageInfo(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::optional<std::vector<std::shared_ptr<FolderEdge>>>> getEdges(service::FieldParams&& params) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<std::shared_ptr<PageInfo>> getPageInfo(service::FieldParams&& params) const final
		{
			if constexpr (methods::FolderConnectionHas::getPageInfoWithParams<T>)
			{
				return { _pimpl->getPageInfo(std::move(params)) };
			}
			else if constexpr (methods::FolderConnectionHas::getPageInfo<T>)
			{
				return { _pimpl->getPageInfo() };
			}
			else
			{
				throw std::runtime_error(R"ex(FolderConnection::getPageInfo is not implemented)ex");
			}
		}

		service::FieldResult<std::optional<std::vector<std::shared_ptr<FolderEdge>>>> getEdges(service::FieldParams&& params) const final
		{
			if constexpr (methods::FolderConnectionHas::getEdgesWithParams<T>)
			{
				return { _pimpl->getEdges(std::move(params)) };
			}
			else if constexpr (methods::FolderConnectionHas::getEdges<T>)
			{
				return { _pimpl->getEdges() };
			}
			else
			{
				throw std::runtime_error(R"ex(FolderConnection::getEdges is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::FolderConnectionHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::FolderConnectionHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	FolderConnection(std::unique_ptr<Concept>&& pimpl) noexcept;

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	FolderConnection(std::shared_ptr<T> pimpl) noexcept
		: FolderConnection { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class CompleteTaskPayload
	: public service::Object
{
private:
	service::AwaitableResolver resolveTask(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveClientMutationId(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<std::shared_ptr<Task>> getTask(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::optional<std::string>> getClientMutationId(service::FieldParams&& params) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<std::shared_ptr<Task>> getTask(service::FieldParams&& params) const final
		{
			if constexpr (methods::CompleteTaskPayloadHas::getTaskWithParams<T>)
			{
				return { _pimpl->getTask(std::move(params)) };
			}
			else if constexpr (methods::CompleteTaskPayloadHas::getTask<T>)
			{
				return { _pimpl->getTask() };
			}
			else
			{
				throw std::runtime_error(R"ex(CompleteTaskPayload::getTask is not implemented)ex");
			}
		}

		service::FieldResult<std::optional<std::string>> getClientMutationId(service::FieldParams&& params) const final
		{
			if constexpr (methods::CompleteTaskPayloadHas::getClientMutationIdWithParams<T>)
			{
				return { _pimpl->getClientMutationId(std::move(params)) };
			}
			else if constexpr (methods::CompleteTaskPayloadHas::getClientMutationId<T>)
			{
				return { _pimpl->getClientMutationId() };
			}
			else
			{
				throw std::runtime_error(R"ex(CompleteTaskPayload::getClientMutationId is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::CompleteTaskPayloadHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::CompleteTaskPayloadHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	CompleteTaskPayload(std::unique_ptr<Concept>&& pimpl) noexcept;

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	CompleteTaskPayload(std::shared_ptr<T> pimpl) noexcept
		: CompleteTaskPayload { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class Mutation
	: public service::Object
{
private:
	service::AwaitableResolver resolveCompleteTask(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveSetFloat(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<std::shared_ptr<CompleteTaskPayload>> applyCompleteTask(service::FieldParams&& params, CompleteTaskInput&& inputArg) const = 0;
		virtual service::FieldResult<double> applySetFloat(service::FieldParams&& params, double&& valueArg) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<std::shared_ptr<CompleteTaskPayload>> applyCompleteTask(service::FieldParams&& params, CompleteTaskInput&& inputArg) const final
		{
			if constexpr (methods::MutationHas::applyCompleteTaskWithParams<T>)
			{
				return { _pimpl->applyCompleteTask(std::move(params), std::move(inputArg)) };
			}
			else if constexpr (methods::MutationHas::applyCompleteTask<T>)
			{
				return { _pimpl->applyCompleteTask(std::move(inputArg)) };
			}
			else
			{
				throw std::runtime_error(R"ex(Mutation::applyCompleteTask is not implemented)ex");
			}
		}

		service::FieldResult<double> applySetFloat(service::FieldParams&& params, double&& valueArg) const final
		{
			if constexpr (methods::MutationHas::applySetFloatWithParams<T>)
			{
				return { _pimpl->applySetFloat(std::move(params), std::move(valueArg)) };
			}
			else if constexpr (methods::MutationHas::applySetFloat<T>)
			{
				return { _pimpl->applySetFloat(std::move(valueArg)) };
			}
			else
			{
				throw std::runtime_error(R"ex(Mutation::applySetFloat is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::MutationHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::MutationHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	Mutation(std::unique_ptr<Concept>&& pimpl) noexcept;

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	Mutation(std::shared_ptr<T> pimpl) noexcept
		: Mutation { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class Subscription
	: public service::Object
{
private:
	service::AwaitableResolver resolveNextAppointmentChange(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveNodeChange(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<std::shared_ptr<Appointment>> getNextAppointmentChange(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::shared_ptr<Node>> getNodeChange(service::FieldParams&& params, response::IdType&& idArg) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<std::shared_ptr<Appointment>> getNextAppointmentChange(service::FieldParams&& params) const final
		{
			if constexpr (methods::SubscriptionHas::getNextAppointmentChangeWithParams<T>)
			{
				return { _pimpl->getNextAppointmentChange(std::move(params)) };
			}
			else if constexpr (methods::SubscriptionHas::getNextAppointmentChange<T>)
			{
				return { _pimpl->getNextAppointmentChange() };
			}
			else
			{
				throw std::runtime_error(R"ex(Subscription::getNextAppointmentChange is not implemented)ex");
			}
		}

		service::FieldResult<std::shared_ptr<Node>> getNodeChange(service::FieldParams&& params, response::IdType&& idArg) const final
		{
			if constexpr (methods::SubscriptionHas::getNodeChangeWithParams<T>)
			{
				return { _pimpl->getNodeChange(std::move(params), std::move(idArg)) };
			}
			else if constexpr (methods::SubscriptionHas::getNodeChange<T>)
			{
				return { _pimpl->getNodeChange(std::move(idArg)) };
			}
			else
			{
				throw std::runtime_error(R"ex(Subscription::getNodeChange is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::SubscriptionHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::SubscriptionHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	Subscription(std::unique_ptr<Concept>&& pimpl) noexcept;

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	Subscription(std::shared_ptr<T> pimpl) noexcept
		: Subscription { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class Appointment
	: public service::Object
{
private:
	service::AwaitableResolver resolveId(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveWhen(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveSubject(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveIsNow(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveForceError(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<response::IdType> getId(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::optional<response::Value>> getWhen(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::optional<std::string>> getSubject(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<bool> getIsNow(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::optional<std::string>> getForceError(service::FieldParams&& params) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<response::IdType> getId(service::FieldParams&& params) const final
		{
			if constexpr (methods::AppointmentHas::getIdWithParams<T>)
			{
				return { _pimpl->getId(std::move(params)) };
			}
			else if constexpr (methods::AppointmentHas::getId<T>)
			{
				return { _pimpl->getId() };
			}
			else
			{
				throw std::runtime_error(R"ex(Appointment::getId is not implemented)ex");
			}
		}

		service::FieldResult<std::optional<response::Value>> getWhen(service::FieldParams&& params) const final
		{
			if constexpr (methods::AppointmentHas::getWhenWithParams<T>)
			{
				return { _pimpl->getWhen(std::move(params)) };
			}
			else if constexpr (methods::AppointmentHas::getWhen<T>)
			{
				return { _pimpl->getWhen() };
			}
			else
			{
				throw std::runtime_error(R"ex(Appointment::getWhen is not implemented)ex");
			}
		}

		service::FieldResult<std::optional<std::string>> getSubject(service::FieldParams&& params) const final
		{
			if constexpr (methods::AppointmentHas::getSubjectWithParams<T>)
			{
				return { _pimpl->getSubject(std::move(params)) };
			}
			else if constexpr (methods::AppointmentHas::getSubject<T>)
			{
				return { _pimpl->getSubject() };
			}
			else
			{
				throw std::runtime_error(R"ex(Appointment::getSubject is not implemented)ex");
			}
		}

		service::FieldResult<bool> getIsNow(service::FieldParams&& params) const final
		{
			if constexpr (methods::AppointmentHas::getIsNowWithParams<T>)
			{
				return { _pimpl->getIsNow(std::move(params)) };
			}
			else if constexpr (methods::AppointmentHas::getIsNow<T>)
			{
				return { _pimpl->getIsNow() };
			}
			else
			{
				throw std::runtime_error(R"ex(Appointment::getIsNow is not implemented)ex");
			}
		}

		service::FieldResult<std::optional<std::string>> getForceError(service::FieldParams&& params) const final
		{
			if constexpr (methods::AppointmentHas::getForceErrorWithParams<T>)
			{
				return { _pimpl->getForceError(std::move(params)) };
			}
			else if constexpr (methods::AppointmentHas::getForceError<T>)
			{
				return { _pimpl->getForceError() };
			}
			else
			{
				throw std::runtime_error(R"ex(Appointment::getForceError is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::AppointmentHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::AppointmentHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	Appointment(std::unique_ptr<Concept>&& pimpl) noexcept;

	// Interface objects need access to these methods
	friend Node;

	template <class I>
	static constexpr bool implements() noexcept
	{
		return implements::AppointmentIs<I>;
	}

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	Appointment(std::shared_ptr<T> pimpl) noexcept
		: Appointment { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class Task
	: public service::Object
{
private:
	service::AwaitableResolver resolveId(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveTitle(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveIsComplete(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<response::IdType> getId(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::optional<std::string>> getTitle(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<bool> getIsComplete(service::FieldParams&& params) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<response::IdType> getId(service::FieldParams&& params) const final
		{
			if constexpr (methods::TaskHas::getIdWithParams<T>)
			{
				return { _pimpl->getId(std::move(params)) };
			}
			else if constexpr (methods::TaskHas::getId<T>)
			{
				return { _pimpl->getId() };
			}
			else
			{
				throw std::runtime_error(R"ex(Task::getId is not implemented)ex");
			}
		}

		service::FieldResult<std::optional<std::string>> getTitle(service::FieldParams&& params) const final
		{
			if constexpr (methods::TaskHas::getTitleWithParams<T>)
			{
				return { _pimpl->getTitle(std::move(params)) };
			}
			else if constexpr (methods::TaskHas::getTitle<T>)
			{
				return { _pimpl->getTitle() };
			}
			else
			{
				throw std::runtime_error(R"ex(Task::getTitle is not implemented)ex");
			}
		}

		service::FieldResult<bool> getIsComplete(service::FieldParams&& params) const final
		{
			if constexpr (methods::TaskHas::getIsCompleteWithParams<T>)
			{
				return { _pimpl->getIsComplete(std::move(params)) };
			}
			else if constexpr (methods::TaskHas::getIsComplete<T>)
			{
				return { _pimpl->getIsComplete() };
			}
			else
			{
				throw std::runtime_error(R"ex(Task::getIsComplete is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::TaskHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::TaskHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	Task(std::unique_ptr<Concept>&& pimpl) noexcept;

	// Interface objects need access to these methods
	friend Node;

	template <class I>
	static constexpr bool implements() noexcept
	{
		return implements::TaskIs<I>;
	}

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	Task(std::shared_ptr<T> pimpl) noexcept
		: Task { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class Folder
	: public service::Object
{
private:
	service::AwaitableResolver resolveId(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveName(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveUnreadCount(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<response::IdType> getId(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::optional<std::string>> getName(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<int> getUnreadCount(service::FieldParams&& params) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<response::IdType> getId(service::FieldParams&& params) const final
		{
			if constexpr (methods::FolderHas::getIdWithParams<T>)
			{
				return { _pimpl->getId(std::move(params)) };
			}
			else if constexpr (methods::FolderHas::getId<T>)
			{
				return { _pimpl->getId() };
			}
			else
			{
				throw std::runtime_error(R"ex(Folder::getId is not implemented)ex");
			}
		}

		service::FieldResult<std::optional<std::string>> getName(service::FieldParams&& params) const final
		{
			if constexpr (methods::FolderHas::getNameWithParams<T>)
			{
				return { _pimpl->getName(std::move(params)) };
			}
			else if constexpr (methods::FolderHas::getName<T>)
			{
				return { _pimpl->getName() };
			}
			else
			{
				throw std::runtime_error(R"ex(Folder::getName is not implemented)ex");
			}
		}

		service::FieldResult<int> getUnreadCount(service::FieldParams&& params) const final
		{
			if constexpr (methods::FolderHas::getUnreadCountWithParams<T>)
			{
				return { _pimpl->getUnreadCount(std::move(params)) };
			}
			else if constexpr (methods::FolderHas::getUnreadCount<T>)
			{
				return { _pimpl->getUnreadCount() };
			}
			else
			{
				throw std::runtime_error(R"ex(Folder::getUnreadCount is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::FolderHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::FolderHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	Folder(std::unique_ptr<Concept>&& pimpl) noexcept;

	// Interface objects need access to these methods
	friend Node;

	template <class I>
	static constexpr bool implements() noexcept
	{
		return implements::FolderIs<I>;
	}

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	Folder(std::shared_ptr<T> pimpl) noexcept
		: Folder { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class NestedType
	: public service::Object
{
private:
	service::AwaitableResolver resolveDepth(service::ResolverParams&& params) const;
	service::AwaitableResolver resolveNested(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<int> getDepth(service::FieldParams&& params) const = 0;
		virtual service::FieldResult<std::shared_ptr<NestedType>> getNested(service::FieldParams&& params) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<int> getDepth(service::FieldParams&& params) const final
		{
			if constexpr (methods::NestedTypeHas::getDepthWithParams<T>)
			{
				return { _pimpl->getDepth(std::move(params)) };
			}
			else if constexpr (methods::NestedTypeHas::getDepth<T>)
			{
				return { _pimpl->getDepth() };
			}
			else
			{
				throw std::runtime_error(R"ex(NestedType::getDepth is not implemented)ex");
			}
		}

		service::FieldResult<std::shared_ptr<NestedType>> getNested(service::FieldParams&& params) const final
		{
			if constexpr (methods::NestedTypeHas::getNestedWithParams<T>)
			{
				return { _pimpl->getNested(std::move(params)) };
			}
			else if constexpr (methods::NestedTypeHas::getNested<T>)
			{
				return { _pimpl->getNested() };
			}
			else
			{
				throw std::runtime_error(R"ex(NestedType::getNested is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::NestedTypeHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::NestedTypeHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	NestedType(std::unique_ptr<Concept>&& pimpl) noexcept;

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	NestedType(std::shared_ptr<T> pimpl) noexcept
		: NestedType { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

class Expensive
	: public service::Object
{
private:
	service::AwaitableResolver resolveOrder(service::ResolverParams&& params) const;

	service::AwaitableResolver resolve_typename(service::ResolverParams&& params) const;

	struct Concept
	{
		virtual ~Concept() = default;

		virtual void beginSelectionSet(const service::SelectionSetParams& params) const = 0;
		virtual void endSelectionSet(const service::SelectionSetParams& params) const = 0;

		virtual service::FieldResult<int> getOrder(service::FieldParams&& params) const = 0;
	};

	template <class T>
	struct Model
		: Concept
	{
		Model(std::shared_ptr<T>&& pimpl) noexcept
			: _pimpl { std::move(pimpl) }
		{
		}

		service::FieldResult<int> getOrder(service::FieldParams&& params) const final
		{
			if constexpr (methods::ExpensiveHas::getOrderWithParams<T>)
			{
				return { _pimpl->getOrder(std::move(params)) };
			}
			else if constexpr (methods::ExpensiveHas::getOrder<T>)
			{
				return { _pimpl->getOrder() };
			}
			else
			{
				throw std::runtime_error(R"ex(Expensive::getOrder is not implemented)ex");
			}
		}

		void beginSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::ExpensiveHas::beginSelectionSet<T>)
			{
				_pimpl->beginSelectionSet(params);
			}
		}

		void endSelectionSet(const service::SelectionSetParams& params) const final
		{
			if constexpr (methods::ExpensiveHas::endSelectionSet<T>)
			{
				_pimpl->endSelectionSet(params);
			}
		}

	private:
		const std::shared_ptr<T> _pimpl;
	};

	Expensive(std::unique_ptr<Concept>&& pimpl) noexcept;

	service::TypeNames getTypeNames() const noexcept;
	service::ResolverMap getResolvers() const noexcept;

	void beginSelectionSet(const service::SelectionSetParams& params) const final;
	void endSelectionSet(const service::SelectionSetParams& params) const final;

	const std::unique_ptr<Concept> _pimpl;

public:
	template <class T>
	Expensive(std::shared_ptr<T> pimpl) noexcept
		: Expensive { std::unique_ptr<Concept> { std::make_unique<Model<T>>(std::move(pimpl)) } }
	{
	}
};

} // namespace object

class Operations
	: public service::Request
{
public:
	explicit Operations(std::shared_ptr<object::Query> query, std::shared_ptr<object::Mutation> mutation, std::shared_ptr<object::Subscription> subscription);

	template <class TQuery, class TMutation, class TSubscription>
	explicit Operations(std::shared_ptr<TQuery> query, std::shared_ptr<TMutation> mutation, std::shared_ptr<TSubscription> subscription)
		: Operations { std::make_shared<object::Query>(std::move(query)), std::make_shared<object::Mutation>(std::move(mutation)), std::make_shared<object::Subscription>(std::move(subscription)) }
	{
	}

private:
	std::shared_ptr<object::Query> _query;
	std::shared_ptr<object::Mutation> _mutation;
	std::shared_ptr<object::Subscription> _subscription;
};

std::shared_ptr<schema::Schema> GetSchema();

} // namespace today
} // namespace graphql

#endif // TODAYSCHEMA_H
