# Common Field Parameters

The `resolveField` methods generated by `schemagen` will unpack any arguments
matching the `schema` from the `query` and pass those to the `getField` method
defined by the implementer. However, the implementer might need to inspect
shared state or `directives` from the `query`, so the `resolveField` method
also packs that information into a `graphql::service::FieldParams` struct and
passes it to every `getField` method as the first parameter.

## Details of Field Parameters

The `graphql::service::FieldParams` struct is declared in [GraphQLService.h](../include/graphqlservice/GraphQLService.h):
```cpp
// Resolvers may be called in multiple different Operation contexts.
enum class ResolverContext
{
	// Resolving a Query operation.
	Query,

	// Resolving a Mutation operation.
	Mutation,

	// Adding a Subscription. If you need to prepare to send events for this Subsciption
	// (e.g. registering an event sink of your own), this is a chance to do that.
	NotifySubscribe,

	// Resolving a Subscription event.
	Subscription,

	// Removing a Subscription. If there are no more Subscriptions registered this is an
	// opportunity to release resources which are no longer needed.
	NotifyUnsubscribe,
};

// Pass a common bundle of parameters to all of the generated Object::getField accessors in a
// SelectionSet
struct SelectionSetParams
{
	// Context for this selection set.
	const ResolverContext resolverContext;

	// The lifetime of each of these borrowed references is guaranteed until the future returned
	// by the accessor is resolved or destroyed. They are owned by the OperationData shared pointer.
	const std::shared_ptr<RequestState>& state;
	const response::Value& operationDirectives;
	const response::Value& fragmentDefinitionDirectives;

	// Fragment directives are shared for all fields in that fragment, but they aren't kept alive
	// after the call to the last accessor in the fragment. If you need to keep them alive longer,
	// you'll need to explicitly copy them into other instances of response::Value.
	const response::Value& fragmentSpreadDirectives;
	const response::Value& inlineFragmentDirectives;

	// Field error path to this selection set.
	std::optional<field_path> errorPath;

	// Async launch policy for sub-field resolvers.
	const std::launch launch = std::launch::deferred;
};

// Pass a common bundle of parameters to all of the generated Object::getField accessors.
struct FieldParams : SelectionSetParams
{
	GRAPHQLSERVICE_EXPORT explicit FieldParams(
		SelectionSetParams&& selectionSetParams, response::Value&& directives);

	// Each field owns its own field-specific directives. Once the accessor returns it will be
	// destroyed, but you can move it into another instance of response::Value to keep it alive
	// longer.
	response::Value fieldDirectives;
};
```

### Resolver Context

The `SelectionSetParams::resolverContext` enum member informs the `getField`
accessors about what type of operation is being resolved.

### Request State

The `SelectionSetParams::state` member is a reference to the
`std::shared_ptr<graphql::service::RequestState>` parameter passed to
`Request::resolve` (see [resolvers.md](./resolvers.md) for more info):
```cpp
// The RequestState is nullable, but if you have multiple threads processing requests and there's any
// per-request state that you want to maintain throughout the request (e.g. optimizing or batching
// backend requests), you can inherit from RequestState and pass it to Request::resolve to correlate the
// asynchronous/recursive callbacks and accumulate state in it.
struct RequestState : std::enable_shared_from_this<RequestState>
{
};
```

### Scoped Directives

Each of the `directives` members contains the values of the `directives` and
any of their arguments which were in effect at that scope of the `query`.
Implementers may inspect those values in the call to `getField` and alter their
behavior based on those custom `directives`.

As noted in the comments, the `fragmentSpreadDirectives` and
`inlineFragmentDirectives` are borrowed `const` references, shared accross
calls to multiple `getField` methods, but they will not be kept alive after
the relevant `SelectionSet` has been resolved. The `fieldDirectives` member is
passed by value and is not shared with other `getField` method calls, but it
will not be kept alive after that call returns. It's up to the implementer to
capture the values in these `directives` which they might need for asynchronous
evaulation after the call to the current `getField` method has returned.

The implementer does not need to capture the values of `operationDirectives`
or `fragmentDefinitionDirectives` because those are kept alive until the
`operation` and all of its `std::future` results are resolved. Although they
passed by `const` reference, the reference should always be valid as long as
there's a pending result from the `getField` call.

### Error Path

The `SelectionSetParams::errorPath` member should be considered an opaque
implementation detail by client code. It automatically propagates through the
field resolvers, and if there is a schema exception or one of the `getField`
accessors throws another exception derived from `std::exception`, the
`graphqlservice` library will automatically add the resulting path to the error
report, accoring to the [spec](https://spec.graphql.org/October2021/#sec-Errors).

### Launch Policy

The `graphqlservice` library uses the `SelectionSetParams::launch` parameter to
determine how it should handle async resolvers in the same selection set or
elements in the same list. It is passed from the top-most `resolve`, `deliver`,
or async `subscribe`/`unsubscribe` call. The `getField` accessors get a copy of
this member in their `FieldParams` argument, and they may change their own
behavior based on that, but they cannot alter the launch policy which
`graphqlservice` uses for the resolvers themselves.

## Related Documents

1. The `getField` methods are discussed in more detail in [resolvers.md](./resolvers.md).
2. Built-in and custom `directives` are discussed in [directives.md](./directives.md).
3. Subscription resolvers get called up to 3 times depending on which
`subscribe`/`unsubscribe` overrides you call. See [subscriptions.md](./subscriptions.md)
for more details.